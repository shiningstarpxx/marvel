## 背景

代码目录在github上是？？？

#### 排列

在c/c++下，用STL的标准实现

```c++
#include <iostream>
#include <algorithm>

using namespace std;

int main()
{
    int data[4] = {5, 2, 1, 4};
    sort(data, data + 4);

    do
    {
        for (int i = 0; i < 4; i++)
            cout << data[i] << " ";
        cout << endl;
    } while (next_permutation(data, data + 4) /* condition */);

    return 0;
}
```



那么接着来看，我们如何来自己实现全排列

1. PartialPermutation: 实现了在begin， end中，对partial个数字做排列

2. Permutation: 实现了在begin，end中的数字做全排列

可以想想为啥是begin == partial 的时候来打印，本质上是下面的逻辑

1. 第一个数字依次和后面交换
2. 第二个数字依次和后面交换
3. ....
4. 直到最后一个数字

所以begin第几，以为前面几个数字就不会再改变了，所以N个数的M排列就是(0, N, M)

```c++
#include <iostream>
#include <algorithm>
#include <time.h>

using namespace std;

int data[] = {1, 2, 3, 4, 5, 6, 8, 9, 10, 32, 15, 18, 33};
int num = 0;  // permutation count
void PartialPermutation(int begin, int end, int partial, bool p = false);

void Permutation(int begin, int end) {
    PartialPermutation(begin, end, end - begin + 1);
}

void PartialPermutation(int begin, int end, int partial, bool p) {
    if (begin == partial) {
        if (p) {
            for (int i = 0; i < partial; i++) {
                cout << data[i] << " ";
            }
            cout << endl;
        }
        num++;
        return;
    } else {
        for (int i = begin; i <= end; ++i) {
            swap(data[i], data[begin]);
            PartialPermutation(begin + 1, end, partial);
            swap(data[i], data[begin]);
        }
    }
}

int main() {
    clock_t start, end;
    start = clock();
    Permutation(0, 9);
    end = clock();
    cout << num << ", " << (double)(end - start)/CLOCKS_PER_SEC << endl;

    num = 0;
    PartialPermutation(0, 9, 3);
    cout << num << endl;
}

```



#### 组合问题

组合问题实际上是排列问题的子问题。通常的解法就是把这些数字的下标二进制化。举例来说a[4] = [1, 2, 3, 4], 那么整个解空间就是

a[0], a[1], a[2], a[3]  = _, _, _, _, 而 _ 可以是0或者1，那么整个全排列的解空间就是0 ～ 2^4 - 1

```c++
#include <iostream>

using namespace std;

void PrintSubset(int n ) {
    for (int i = 0; i < (1 << n); ++i) {
        for (int j = 0; j < n; ++j) {
            if (i & (1 << j)) {
                cout << j << " ";
            }
        }
        cout << endl;
    }
}

int main() {
    int n;
    cin >> n;
    PrintSubset(n);
    return 0;
}
```

组合问题里进一步更复杂的是C(N, M), 也就是N个数中取M个数，应该怎么做? 这里有几个步骤，就是枚举全部解的时候，需要判断，当前这个组合中1个的个数，也就是数组元素选中的个数是否等于M。那么接下来，怎么知道目前这个数字有几个1呢？具体步骤如下， 假设当前值是kk，num表示1的计数，初始化为0:

1. 用 kk = kk & (kk - 1) 清楚最后一个1
2. num++
3. 持续上面的操作直到 kk = 0

```c++
#include <iostream>

using namespace std;

int CountOnes(int n) {
    int count = 0;
    while (n) {
        n = n & (n - 1);
        count++;
    }
    return count;
}

void PrintPartialSet(int n, int k) {
    for (int i = 0; i < (1 << n); ++i) {
        if (CountOnes(i) == k) {
            for (int j = 0; j < n; ++j) {
                if (i & (1 << j))
                    cout << j << " ";
            }
            cout << endl;
        }
    }
}

int main() {
    int n, k;
    cin >> n >> k;
    PrintPartialSet(n, k);
    return 0;
}
```

#### 广度搜索BFS

深度优先搜索和广度优先搜索是基本的暴力技术，通常用于解决图，树的遍历问题。

##### A*算法

##### 双广搜索

在搜索的过程中，如果即给了source，又给了target，那么在bfs的时候是否可以两边都来做探索，然后看看双方是否可以在中间的某个部分有交集，也就是找到了解。向前的集合如果越来越大，那么往后的搜索就有可能会带来收益。

这道 LeetCode 题目是第 752 题，比较有意思：

```c++
/*
 * @lc app=leetcode.cn id=752 lang=cpp
 *
 * [752] 打开转盘锁
 */
#include <deque>
#include <string>
#include <unordered_set>
#include <vector>

using namespace std;

// @lc code=start
class Solution {
 public:
  string PlusOne(string s, int index) {
    if (s[index] != '9')
      s[index] = s[index] - '0' + 1 + '0';
    else
      s[index] = '0';
    return s;
  }
  string MinusOne(string s, int index) {
    if (s[index] != '0')
      s[index] = s[index] - '0' - 1 + '0';
    else
      s[index] = '9';
    return s;
  }
  void AddToNextState(string tt, unordered_set<string> *cache,
                      deque<string> *state) {
    if (cache->find(tt) == cache->end()) {
      cache->insert(tt);
      state->push_back(tt);
    }
  }
  void SwitchNewState(string t, int i, unordered_set<string> *cache,
                      deque<string> *state) {
    // 前进
    string f = PlusOne(t, i);
    AddToNextState(f, cache, state);
    // 后退
    string b = MinusOne(t, i);
    AddToNextState(b, cache, state);
  }
  int openLock(vector<string> &deadends, string target) {
    deque<string> state;
    unordered_set<string> cache(deadends.begin(), deadends.end());
    if (cache.count("0000")) return -1;

    int step = 0;
    state.push_back("0000");
    while (!state.empty()) {
      deque<string> c;
      swap(c, state);
      while (!c.empty()) {
        string t = c.front();
        if (t == target) return step;
        c.pop_front();
        for (int i = 0; i < t.size(); ++i) {
          SwitchNewState(t, i, &cache, &state);
        }
      }
      ++step;
    }
    return -1;
  }
};
// @lc code=end

```

对应的评价效果

```
Accepted
47/47 cases passed (264 ms)
Your runtime beats 61.31 % of cpp submissions
Your memory usage beats 37.19 % of cpp submissions (34.5 MB)
```

下面是我们使用双向dfs的代码

```c++
#include <iostream>
#include <string>
#include <unordered_set>
#include <vector>

using namespace std;

// @lc code=start
class Solution {
 public:
  string PlusOne(string s, int index) {
    if (s[index] != '9')
      s[index] = s[index] - '0' + 1 + '0';
    else
      s[index] = '0';
    return s;
  }
  string MinusOne(string s, int index) {
    if (s[index] != '0')
      s[index] = s[index] - '0' - 1 + '0';
    else
      s[index] = '9';
    return s;
  }

  void OnlyAddToNextState(string tt, unordered_set<string> *cache,
                          unordered_set<string> *state) {
    if (cache->find(tt) == cache->end()) {
      state->insert(tt);
    }
  }
  void OnlySwitchNewState(string t, int i, unordered_set<string> *cache,
                          unordered_set<string> *state) {
    // 前进
    string f = PlusOne(t, i);
    OnlyAddToNextState(f, cache, state);
    // 后退
    string b = MinusOne(t, i);
    OnlyAddToNextState(b, cache, state);
  }

  int openLock(vector<string> &deadends, string target) {
    return DoulbleBFS(deadends, target);
  }
  int DoulbleBFS(vector<string> &deadends, string target) {
    unordered_set<string> state;
    unordered_set<string> ts;
    unordered_set<string> cache(deadends.begin(), deadends.end());
    if (cache.count("0000")) return -1;

    int step = 0;
    state.insert("0000");
    ts.insert(target);
    while (!state.empty() && !ts.empty()) {
      unordered_set<string> c;
      swap(c, state);
      for (auto it = c.begin(); it != c.end(); ++it) {
        string t = *it;
        if (ts.find(t) != ts.end()) return step;
        cache.insert(t);
        for (int i = 0; i < t.size(); ++i) {
          OnlySwitchNewState(t, i, &cache, &state);
        }
      }
      if (ts.size() < state.size()) swap(ts, state);
      ++step;
    }
    return -1;
  }
};
```

对应的效果得到了大幅度的提升

```
Accepted
47/47 cases passed (88 ms)
Your runtime beats 93.22 % of cpp submissions
Your memory usage beats 97.34 % of cpp submissions (15.9 MB)
```



#### 深度搜索DFS





#### References

很不错的算法总结网站 https://labuladong.github.io/algo/

